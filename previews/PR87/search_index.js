var documenterSearchIndex = {"docs":
[{"location":"localsearch/kmeans/#k-means","page":"k-means","title":"k-means","text":"","category":"section"},{"location":"metaheuristic/random_swap/#Random-Swap","page":"Random Swap","title":"Random Swap","text":"","category":"section"},{"location":"metaheuristic/random_swap/#UnsupervisedClustering.RandomSwap","page":"Random Swap","title":"UnsupervisedClustering.RandomSwap","text":"RandomSwap(\n    local_search::AbstractAlgorithm\n    verbose::Bool = DEFAULT_VERBOSE\n    max_iterations::Int = 200\n    max_iterations_without_improvement::Int = 150\n)\n\nRandomSwap is a meta-heuristic approach used for clustering problems. It follows an iterative process that combines local optimization with perturbation to explore the search space effectively. A local optimization algorithm is applied at each iteration to converge toward a local optimum. Then, a perturbation operator generates a new starting point and continues the search.\n\nFields\n\nlocal_search: the clustering algorithm applied to improve the solution in each meta-heuristics iteration.\nverbose: controls whether the algorithm should display additional information during execution.\nmax_iterations: represents the maximum number of iterations the algorithm will perform before stopping.\nmax_iterations_without_improvement: represents the maximum number of iterations allowed without improving the best solution.\n\nReferences\n\nFränti, Pasi. Efficiency of random swap clustering. Journal of big data 5.1 (2018): 1-29.\n\n\n\n\n\n","category":"type"},{"location":"metaheuristic/random_swap/#UnsupervisedClustering.fit-Union{Tuple{LS}, Tuple{RandomSwap{LS}, AbstractMatrix{<:Real}, Integer}} where LS<:UnsupervisedClustering.AbstractAlgorithm","page":"Random Swap","title":"UnsupervisedClustering.fit","text":"fit(\n    meta::RandomSwap,\n    data::AbstractMatrix{<:Real},\n    k::Integer\n)\n\nThe fit function applies a random swap to a clustering problem and returns a result object representing the clustering outcome.\n\nParameters:\n\nmeta: an instance representing the clustering settings and parameters.\ndata: a floating-point matrix, where each row represents a data point, and each column represents a feature.\nk: an integer representing the number of clusters.\n\nExample\n\nn = 100\nd = 2\nk = 2\n\ndata = rand(n, d)\n\nkmeans = Kmeans()\nrandom_swap = RandomSwap(local_search = kmeans)\nresult = fit(random_swap, data, k)\n\n\n\n\n\n","category":"method"},{"location":"localsearch/gmm/#GMM","page":"GMM","title":"GMM","text":"","category":"section"},{"location":"ensemble/chain/#Clustering-Chain","page":"Clustering Chain","title":"Clustering Chain","text":"","category":"section"},{"location":"ensemble/chain/#UnsupervisedClustering.ClusteringChain","page":"Clustering Chain","title":"UnsupervisedClustering.ClusteringChain","text":"ClusteringChain(algorithms::AbstractAlgorithm...)\n\nClusteringChain represents a chain of clustering algorithms that are executed sequentially. It allows for applying multiple clustering algorithms in a specific order to refine and improve the clustering results.\n\nFields\n\nalgorithms: the vector of clustering algorithms that will be executed in sequence.\n\n\n\n\n\n","category":"type"},{"location":"ensemble/chain/#UnsupervisedClustering.fit-Union{Tuple{T}, Tuple{ClusteringChain{T}, AbstractMatrix{<:Real}, Integer}} where T<:UnsupervisedClustering.AbstractAlgorithm","page":"Clustering Chain","title":"UnsupervisedClustering.fit","text":"fit(chain::ClusteringChain, data::AbstractMatrix{<:Real}, k::Integer)\n\nThe fit function applies a sequence of clustering algorithms and returns a result object representing the clustering outcome.\n\nParameters:\n\nmeta: an instance representing the clustering settings and parameters.\ndata: a floating-point matrix, where each row represents a data point, and each column represents a feature.\nk: an integer representing the number of clusters.\n\nExample\n\nn = 100\nd = 2\nk = 2\n\ndata = rand(n, d)\n\nkmeans = Kmeans()\ngmm = GMM(estimator = EmpiricalCovarianceMatrix(n, d))\n\nchain = ClusteringChain(kmeans, gmm)\nresult = fit(chain, data, k)\n\n\n\n\n\n","category":"method"},{"location":"localsearch/kmedoids/#k-medoids","page":"k-medoids","title":"k-medoids","text":"","category":"section"},{"location":"metaheuristic/multi_start/#Multi-Start","page":"Multi-Start","title":"Multi-Start","text":"","category":"section"},{"location":"metaheuristic/multi_start/#UnsupervisedClustering.MultiStart","page":"Multi-Start","title":"UnsupervisedClustering.MultiStart","text":"MultiStart(\n    local_search::AbstractAlgorithm\n    verbose::Bool = DEFAULT_VERBOSE\n    max_iterations::Int = 200\n)\n\nThe MultiStart approach repeatedly applies a clustering algorithm to generate multiple solutions with different initial points and selects the best solution.\n\nFields\n\nlocal_search: the clustering algorithm applied to improve the solution in each meta-heuristics iteration.\nverbose: controls whether the algorithm should display additional information during execution.\nmax_iterations: represents the maximum number of iterations the algorithm will perform before stopping.\n\n\n\n\n\n","category":"type"},{"location":"metaheuristic/multi_start/#UnsupervisedClustering.fit-Union{Tuple{LS}, Tuple{MultiStart{LS}, AbstractMatrix{<:Real}, Integer}} where LS<:UnsupervisedClustering.AbstractAlgorithm","page":"Multi-Start","title":"UnsupervisedClustering.fit","text":"fit(\n    meta::MultiStart,\n    data::AbstractMatrix{<:Real},\n    k::Integer\n)\n\nThe fit function applies a multi-start to a clustering problem and returns a result object representing the clustering outcome.\n\nParameters:\n\nmeta: an instance representing the clustering settings and parameters.\ndata: a floating-point matrix, where each row represents a data point, and each column represents a feature.\nk: an integer representing the number of clusters.\n\nExample\n\nn = 100\nd = 2\nk = 2\n\ndata = rand(n, d)\n\nkmeans = Kmeans()\nmulti_start = MultiStart(local_search = kmeans)\nresult = fit(multi_start, data, k)\n\n\n\n\n\n","category":"method"},{"location":"#UnsupervisedClustering","page":"Home","title":"UnsupervisedClustering","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"UnsupervisedClustering\")","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find UnsupervisedClustering useful in your work, we kindly request that you cite the following paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{sampaio2024regularization,\n  title={Regularization and optimization in model-based clustering},\n  author={Sampaio, Raphael Araujo and Garcia, Joaquim Dias and Poggi, Marcus and Vidal, Thibaut},\n  journal={Pattern Recognition},\n  pages={110310},\n  year={2024},\n  publisher={Elsevier}\n}","category":"page"},{"location":"metaheuristic/genetic_algorithm/#Genetic-Algorithm","page":"Genetic Algorithm","title":"Genetic Algorithm","text":"","category":"section"},{"location":"metaheuristic/genetic_algorithm/#UnsupervisedClustering.GeneticAlgorithm","page":"Genetic Algorithm","title":"UnsupervisedClustering.GeneticAlgorithm","text":"GeneticAlgorithm(\n    local_search::AbstractAlgorithm\n    verbose::Bool = DEFAULT_VERBOSE\n    max_iterations::Int = 200\n    max_iterations_without_improvement::Int = 150\n    π_min::Int = 40\n    π_max::Int = 50\n)\n\nGeneticAlgorithm represents a clustering algorithm that utilizes a genetic algorithm approach to optimize cluster assignments. It combines evolutionary computation and local search elements to find high-quality clustering solutions.\n\nFields\n\nlocal_search: the clustering algorithm applied to improve the solution in each meta-heuristics iteration.\nverbose: controls whether the algorithm should display additional information during execution.\nmax_iterations: represents the maximum number of iterations the algorithm will perform before stopping.\nmax_iterations_without_improvement: represents the maximum number of iterations allowed without improving the best solution.\nπ_max: the maximum population size used in the genetic algorithm.\nπ_min: the minimum population size used in the genetic algorithm.\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"metaheuristic/genetic_algorithm/#UnsupervisedClustering.fit-Union{Tuple{LS}, Tuple{GeneticAlgorithm{LS}, AbstractMatrix{<:Real}, Integer}} where LS<:UnsupervisedClustering.AbstractAlgorithm","page":"Genetic Algorithm","title":"UnsupervisedClustering.fit","text":"fit(\n    meta::GeneticAlgorithm,\n    data::AbstractMatrix{<:Real},\n    k::Integer\n)\n\nThe fit function applies a genetic algorithm to a clustering problem and returns a result object representing the clustering outcome.\n\nParameters:\n\nmeta: an instance representing the clustering settings and parameters.\ndata: a floating-point matrix, where each row represents a data point, and each column represents a feature.\nk: an integer representing the number of clusters.\n\nExample\n\nn = 100\nd = 2\nk = 2\n\ndata = rand(n, d)\n\nkmeans = Kmeans()\ngenetic_algorithm = GeneticAlgorithm(local_search = kmeans)\nresult = fit(genetic_algorithm, data, k)\n\n\n\n\n\n","category":"method"}]
}
